/*
*******************************************************************
Name  Flying bird
Copyright (C) 2014	Krzysztof Pazdur <pazdurk@gmail.com>

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.

*/
// 
//

#include <SFML\Graphics.hpp>
#include <iostream>
#include <time.h>
#include "headers.h"
#include "Spike.h"
#include "Collision.h"



//
//In this variable stored is current background color;
//	
sf::Color currentCOLOR;

//
// In this variable stored is next color of background from colors array;
//
sf::Color colorbyPoint;



//
// this variable is used by circleText 
// 
sf::String points = "00";
unsigned  uPoints = 0;


//
//		
// this array contain random bool values generated by CDuck::RandSpike	
//
//
//
//
bool SpikeTab[static_cast<unsigned>(WINDOW_Y /   SPIKE_H) - 1] = { false };

//
// Include class CDuck 
//
#include "Duck.h"

/*
	This function changing RGB values of Current Backgorund Color 
	to new color

	@param current color;
	@param new color;
	@param Handle to window.
	@param Handle to font

*/
/****************************************************/
void setFadeColor(sf::Color &currentColor, sf::Color &k, sf::RenderWindow &win, sf::Text &font);
/****************************************************/



int main()
{
	//
	//		
	//	Because I need it to randomize 
	//	duck's vector and spikes 
	//
	srand(time(NULL));

	//
	//	Create Window 
	//	
	sf::VideoMode videoMode(WINDOW_X, WINDOW_Y);
	sf::RenderWindow window(videoMode, WINDOW_TITLE, sf::Style::Titlebar);


	//
	// Set Window max FPS to 100
	// and play music in background
	//
	window.setFramerateLimit(100);
	sf::Music music;
	music.openFromFile( MUSIC_FOLDER "Courage.ogg" );
	music.play();



	//
	//		
	//	Create window border: line by line. 
	//
	// line thickness 10px;
	// color Black
	//
	
	sf::RectangleShape lineTOP;
	lineTOP.setFillColor(sf::Color::Black);
	lineTOP.setPosition(sf::Vector2f(0, 0));
	lineTOP.setSize(sf::Vector2f(300, 10));

	sf::RectangleShape lineLEFT;
	lineLEFT.setFillColor(sf::Color::Black);
	lineLEFT.setPosition(sf::Vector2f(0, 0));
	lineLEFT.setSize(sf::Vector2f(10, 450));

	sf::RectangleShape lineRIGHT;
	lineRIGHT.setFillColor(sf::Color::Black);
	lineRIGHT.setPosition(sf::Vector2f(290, 0));
	lineRIGHT.setSize(sf::Vector2f(10, 440));


	sf::RectangleShape LineBOTTOM;
	LineBOTTOM.setFillColor(sf::Color::Black);
	LineBOTTOM.setPosition(sf::Vector2f(0, 440));
	LineBOTTOM.setSize(sf::Vector2f(300, 10));




	//
	//		
	//	Create Circle
	//  With color RGB(242,242,242) and alpha 199 where alhpa is between 0 and 255;
	//  
	//  Circle radius : 100px;
	//  Circle position: center of window
	sf::CircleShape circle(100);
	circle.setFillColor(sf::Color(242, 242, 242, 199));
	circle.setOrigin(sf::Vector2f(100, 100));
	circle.setPosition(sf::Vector2f(WINDOW_X / 2, WINDOW_Y / 2));


	
	
	//
	//		
	//	Create 10 el array of colors
	//
	sf::Color colors[10];
	colors[0] = sf::Color(209, 250, 142);
	colors[1] = sf::Color(168, 255, 142);
	colors[2] = sf::Color(250, 255, 142);
	colors[3] = sf::Color(255, 189, 190);
	colors[4] = sf::Color(255, 189, 223);
	colors[5] = sf::Color(221, 189, 255);
	colors[6] = sf::Color(189, 190, 255);
	colors[7] = sf::Color(195, 195, 216);
	colors[8] = sf::Color(213, 213, 213);
	colors[9] = sf::Color(233, 255, 142);



	
	
	//
	// Load Font from file to font object;
	//
	// if font not exist them return FONT_NOT_FOUND;
	sf::Font font;
	if (!font.loadFromFile(WINDOW_FONT)) return FONT_NOT_FOUND;




	
	currentCOLOR = colors[0]; // set starts color
	colorbyPoint = colors[0]; // set starts color


	//
	// Create and initialize Duck object
	// 
	// @param App wios
	// @param array of randomized bool values 
	// 
	CDuck Duck(window, SpikeTab);



	// player is playing ? 	
	bool Game = false;


	//
	//		
	//	Main Game loop 
	//  executing until player don't close window.
	//
	//
	//
	while (window.isOpen())
	{


	
		//
		//  Text object 
		// @param current points 
		// @param loaded font;
		sf::Text circleText(points, font);
		setFadeColor(currentCOLOR, colorbyPoint, window, circleText);


		//
		//	Keys Support 	
		//
		sf::Event event;
		while (window.pollEvent(event))
		{
			if ((event.type == sf::Event::Closed) || (event.type == sf::Event::KeyPressed))
			{
				if (event.key.code == sf::Keyboard::Escape)  window.close();
				if (event.key.code == sf::Keyboard::Space && Game == true) Duck.Jump();
				if (event.key.code == sf::Keyboard::Space && Game == false) Game = true;
			}


		} // end While window.pollEvent


		//
		//		
		//	If player is playing
		//
		if (Game == true)
		{


			//
			// set text size to 102 		
			// set text pos to center of window
			// set text origin 
			circleText.setCharacterSize(102);
			circleText.setPosition(sf::Vector2f(WINDOW_X / 2, WINDOW_Y / 2 -25));
			circleText.setOrigin((circleText.getLocalBounds().width / 2) + 5, (circleText.getLocalBounds().height / 2));




			//
			// from unsigned to string;
			// if uPoints < 10 add 0 to string;
			points = (uPoints < 10 ? "0" + std::to_string(uPoints) : std::to_string(uPoints));


			//
			// Change next background
			//

			switch (uPoints)
			{
			case 5:
				colorbyPoint = colors[1];
				break;
			case 10:
				colorbyPoint = colors[2];
				break;
			case 15:
				colorbyPoint = colors[3];
				break;
			case 20:
				colorbyPoint = colors[4];
				break;
			case 25:
				colorbyPoint = colors[5];
				break;
			case 30:
				colorbyPoint = colors[6];
				break;
			case 40:
				colorbyPoint = colors[7];
				break;
			case 45:
				colorbyPoint = colors[8];
				break;
			case 50:
				colorbyPoint = colors[9];
				break;

			default:
				break;
			}




			//
			//	Create Left or Right spikes	
			//
			//
			for (int z = 0; z < static_cast<unsigned>(WINDOW_Y /  SPIKE_H) - 1; z++)
			{
 
 
				if (SpikeTab[z] == true)
				{

					//
					//	Create spikes  	
					// 
					// @param Window
					// @param enum Position  
					// @param x cord
					// @param y cord
					CSpike Spike(window, (Duck.cSide == 0 ? Right : Left), 10, (z * 41) + 11);
					//if (z != static_cast<unsigned>(WINDOW_Y /  SPIKE_H) - 1)
						Spike.Update();
						
						
					//
					//	Detect collision between Duck and Spike	
					//
					if (Collision::PixelPerfectTest(Duck.model, Spike.model))
					{
						Game = false; // player lose
						Duck.model.setPosition(WINDOW_X / 2, WINDOW_Y / 2); // set model pos to center
						Duck.cSide = rand() % 2; // rand duck's vector
						uPoints = 0; // set 0 points
						Duck.modelMove.y = 0; // set grav to 0
						Duck.RandSpike(); // randomize Spikes
						currentCOLOR = colors[0]; // set current color to default
					}

				}


			}


			
			for (int z = 0; z <= static_cast<unsigned>(WINDOW_X /   SPIKE_H); z++)
			{

				//
				// Top and bottom spikes
				//
				CSpike Spike2(window, Top, (z *   SPIKE_H) + 10, 10);
				Spike2.Update();

				CSpike Spike3(window, Bottom, (z *   SPIKE_H) + 10, WINDOW_Y - 10);
				if (z != static_cast<unsigned>(WINDOW_X /   SPIKE_H))
					Spike3.Update();


					
				if (Collision::PixelPerfectTest(Duck.model, Spike2.model) || Collision::PixelPerfectTest(Duck.model, Spike3.model))
				{
					Game = false;
					Duck.model.setPosition(WINDOW_X / 2, WINDOW_Y / 2);
					Duck.cSide = rand() % 2;
					uPoints = 0;
					Duck.modelMove.y = 0;
					Duck.RandSpike();
					currentCOLOR = colors[0];
				}

			}


		} // if GAME true
		else
		{
			//
			//	Create Start Screen
			//  
			//
			sf::Texture start_modelTeX; // Texture file 
			sf::Sprite start_model;	      // Model 

			
			
			// Load model
			// set texture
			//  position
			// set origin
			if (!start_modelTeX.loadFromFile(TEXTURE_FOLDER "logo.png")) exit(TEXTURE_NOT_FOUND);
			start_model.setTexture(start_modelTeX);
			start_model.setTextureRect(sf::IntRect(0, 0, 274, 291));
			start_model.setOrigin(274 / 2, 291 / 2);
			start_model.setPosition(WINDOW_X / 2, (WINDOW_Y / 2));


			
			
			// score text
			
			circleText.setCharacterSize(50);
			circleText.setPosition(sf::Vector2f(WINDOW_X / 2, WINDOW_Y / 2  -25));
			circleText.setOrigin((circleText.getLocalBounds().width / 2) + 5, (circleText.getLocalBounds().height / 2));


			
			
			//
			//
			window.draw(start_model);
			window.draw(circleText);

		} // else game false


		
		
		//
		//
		window.draw(lineTOP);
		window.draw(lineLEFT);
		window.draw(lineRIGHT);
		window.draw(LineBOTTOM);



		if (Game == true)
		{
			// layer with circle and text on it	
			window.draw(circle);
			window.draw(circleText);


			// firs layer : ONLY MOVING OBJECT
			Duck.Update();
		}


		window.display();
	} // end while window.isOpen
	return EXIT_SUCCESS;
}

/*
	This function changing RGB values of Current Backgorund Color 
	to new color

	@param current color;
	@param new color;
	@param Handle to window.
	@param Handle to font

*/
void setFadeColor(sf::Color &currentColor, sf::Color &k, sf::RenderWindow &win, sf::Text &font)
{
	int tmpR, tmpG, tmpB = 0;
	font.setString(points);
	/*
		config fade for R pat.
	*/
	if (currentColor.r != k.r)
	{

		if (currentColor.r > k.r)
		{
			tmpR = -1;

		}
		else if (currentColor.r < k.r)
		{
			tmpR = 1;

		}

		currentColor.r += tmpR;
		font.setColor(currentColor);

	}
	else
	{
		tmpR = 0;
	}


	/*
		config fade for G pat.
	*/
	if (currentColor.g != k.g)
	{

		if (currentColor.g > k.g)
		{
			tmpG = -1;

		}
		else if (currentColor.g < k.g)
		{
			tmpG = 1;

		}

		currentColor.g += tmpG;
		font.setColor(currentColor);

	}
	else
	{
		tmpG = 0;
	}


	/*
		config fade for B pat.
	*/
	if (currentColor.b != k.b)
	{

		if (currentColor.b > k.b)
		{
			tmpB = -1;
		}
		else if (currentColor.b < k.b)
		{
			tmpB = 1;
		}

		currentColor.b += tmpB;
		font.setColor(currentColor);

	}
	else
	{
		tmpB = 0;
	}
	font.setColor(currentColor);
	win.clear(currentColor);
}
